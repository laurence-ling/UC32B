From 7a47af9b5ff21dedf571b11a16b5fbf66bcfa419 Mon Sep 17 00:00:00 2001
From: GuanXuetao <gxt@mprc.pku.edu.cn>
Date: Wed, 28 Dec 2011 15:20:03 +0800
Subject: [PATCH 7/8] UniCore32: add pkunity-v3 net driver (umal) support

v2 -> v3: adjust codestyle and names.

v1 -> v2:
For the new version of linux, we adjust the directory position and
config/compilation method. And we replace ndo_set_multicast_list
with ndo_set_rx_mode.

v1:
We changed our code from old driver. Thanks the reviews of Arnd and Ben.
1. Use variable type integer to describe umal_speed instead of enum.
2. Changed the name ETHER_ADDR_LEN to ETH_ALEN.
3. Renamed those members in struct umaldmadscr to fit the naming convention.
4. Modified our code skb_reserve(sb_new, 2) to skb_reserve(sb_new,
	SMP_CACHE_BYTES) in function umaldma_add_rcvbuffer.
5. Put judgment statement if (!netif_device_present(dev)) before lock the
	sc->umal in function umaldma_tx_process.
6. Reorder those functions in driver and delete all prototypes.
7. Modified our code comment to fit the demands of kernel-doc.

BTW: For the mac address, we use the fixed, single mac address just for
board test, an mac address is just assigned to our company, so we didn't
choose random_ether_addr().

Cc: Arnd Bergmann <arnd@arndb.de>
Cc: Ben Hutchings <bhutchings@solarflare.com>
Cc: netdev@vger.kernel.org
Cc: "David S. Miller" <davem@davemloft.net>

Signed-off-by: Zhang Shu <davidshuzhang@gmail.com>
Signed-off-by: Chu Xiaowei <chuxiaowei@mprc.pku.edu.cn>
Signed-off-by: Su Yonggang <tonyhook.su@gmail.com>
Signed-off-by: Guan Xuetao <gxt@mprc.pku.edu.cn>
---
 MAINTAINERS                                |    1 +
 arch/unicore32/configs/unicore32_defconfig |    2 +-
 drivers/net/ethernet/Kconfig               |    1 +
 drivers/net/ethernet/Makefile              |    1 +
 drivers/net/ethernet/pkunity/Kconfig       |   33 +
 drivers/net/ethernet/pkunity/Makefile      |    5 +
 drivers/net/ethernet/pkunity/netdev-puv3.c | 1765 ++++++++++++++++++++++++++++
 7 files changed, 1807 insertions(+), 1 deletion(-)
 create mode 100644 drivers/net/ethernet/pkunity/Kconfig
 create mode 100644 drivers/net/ethernet/pkunity/Makefile
 create mode 100644 drivers/net/ethernet/pkunity/netdev-puv3.c

diff --git a/MAINTAINERS b/MAINTAINERS
index 59203e7..d9f80ba 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -5662,6 +5662,7 @@ F:	drivers/input/serio/i8042-unicore32io.h
 F:	drivers/i2c/busses/i2c-puv3.c
 F:	drivers/video/fb-puv3.c
 F:	drivers/rtc/rtc-puv3.c
+F:	drivers/net/ethernet/pkunity/netdev-puv3.c
 
 PMBUS HARDWARE MONITORING DRIVERS
 M:	Guenter Roeck <linux@roeck-us.net>
diff --git a/arch/unicore32/configs/unicore32_defconfig b/arch/unicore32/configs/unicore32_defconfig
index ce704ce..1401213 100644
--- a/arch/unicore32/configs/unicore32_defconfig
+++ b/arch/unicore32/configs/unicore32_defconfig
@@ -61,7 +61,6 @@ CONFIG_I2C_BATTERY_BQ27200=n
 CONFIG_I2C_EEPROM_AT24=n
 CONFIG_LCD_BACKLIGHT=n
 
-CONFIG_PUV3_UMAL=y
 CONFIG_PUV3_MUSB=n
 CONFIG_PUV3_AC97=n
 CONFIG_PUV3_NAND=n
@@ -98,6 +97,7 @@ CONFIG_SATA_VIA=y
 #	Network device support
 CONFIG_NETDEVICES=y
 CONFIG_NET_ETHERNET=y
+CONFIG_NETDEV_PUV3=y
 CONFIG_NETDEV_1000=y
 #	Wireless LAN
 CONFIG_WLAN_80211=n
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index e4ff389..3aff75c 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -134,6 +134,7 @@ config ETHOC
 
 source "drivers/net/ethernet/packetengines/Kconfig"
 source "drivers/net/ethernet/pasemi/Kconfig"
+source "drivers/net/ethernet/pkunity/Kconfig"
 source "drivers/net/ethernet/qlogic/Kconfig"
 source "drivers/net/ethernet/racal/Kconfig"
 source "drivers/net/ethernet/realtek/Kconfig"
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index d447307..429011d 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_NET_VENDOR_OKI) += oki-semi/
 obj-$(CONFIG_ETHOC) += ethoc.o
 obj-$(CONFIG_NET_PACKET_ENGINE) += packetengines/
 obj-$(CONFIG_NET_VENDOR_PASEMI) += pasemi/
+obj-$(CONFIG_NET_VENDOR_PKUNITY) += pkunity/
 obj-$(CONFIG_NET_VENDOR_QLOGIC) += qlogic/
 obj-$(CONFIG_NET_VENDOR_RACAL) += racal/
 obj-$(CONFIG_NET_VENDOR_REALTEK) += realtek/
diff --git a/drivers/net/ethernet/pkunity/Kconfig b/drivers/net/ethernet/pkunity/Kconfig
new file mode 100644
index 0000000..ce14332
--- /dev/null
+++ b/drivers/net/ethernet/pkunity/Kconfig
@@ -0,0 +1,33 @@
+#
+# PKUnity network device configuration
+#
+
+config NET_VENDOR_PKUNITY
+	bool "PKUnity net devices"
+	default y
+	depends on UNICORE32
+	---help---
+	  If you have a network (Ethernet) card belonging to this class, say Y
+	  and read the Ethernet-HOWTO, available from
+	  <http://www.tldp.org/docs.html#howto>.
+
+	  Note that the answer to this question doesn't directly affect the
+	  kernel: saying N will just cause the configurator to skip all
+	  the questions about PKUnity devices. If you say Y, you will be asked
+	  for your specific device in the following questions.
+
+if NET_VENDOR_PKUNITY
+
+config NETDEV_PUV3
+	tristate "PKUnity v3 ethernet device (UMAL) support"
+	depends on ARCH_PUV3
+	select MII
+	select PHYLIB
+	---help---
+	  Say Y here if you intend to attach a Ethernet or Fast Ethernet
+	  device in PKUnity v3 (SoC).
+
+	  To compile this driver as a module, choose M here: the module will be
+	  called netdev-puv3.  If unsure, say N.
+
+endif # NET_VENDOR_PKUNITY
diff --git a/drivers/net/ethernet/pkunity/Makefile b/drivers/net/ethernet/pkunity/Makefile
new file mode 100644
index 0000000..8cc873b
--- /dev/null
+++ b/drivers/net/ethernet/pkunity/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the PKUnity network device drivers.
+#
+
+obj-$(CONFIG_NETDEV_PUV3) += netdev-puv3.o
diff --git a/drivers/net/ethernet/pkunity/netdev-puv3.c b/drivers/net/ethernet/pkunity/netdev-puv3.c
new file mode 100644
index 0000000..4b99fe1
--- /dev/null
+++ b/drivers/net/ethernet/pkunity/netdev-puv3.c
@@ -0,0 +1,1765 @@
+/*
+ * Code specific to PKUnity SoC and UniCore ISA
+ *
+ *	Maintained by GUAN Xue-tao <gxt@mprc.pku.edu.cn>
+ *	Copyright (C) 2001-2010 Guan Xuetao
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/bug.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/init.h>
+#include <linux/bitops.h>
+#include <linux/err.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+#include <linux/cache.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+
+#include <mach/hardware.h>
+
+#define UMAL_NAME	"PKUnity-v3-UMAL"
+
+enum netdev_puv3_flowc {
+	netdev_puv3_flowc_none,
+	netdev_puv3_flowc_disabled,
+	netdev_puv3_flowc_frame,
+	netdev_puv3_flowc_collision,
+	netdev_puv3_flowc_carrier,
+};
+
+enum netdev_puv3_state {
+	netdev_puv3_state_uninit,
+	netdev_puv3_state_off,
+	netdev_puv3_state_on,
+	netdev_puv3_state_broken,
+};
+
+#define UMALDMA_NEXTBUF(d, f) ((((d)->f+1) == (d)->umaldma_desc_table_end) ? \
+			  (d)->umaldma_desc_table : (d)->f+1)
+
+#define UMALDMA_RX		0
+#define UMALDMA_TX		1
+
+#define UMAL_MAX_TXDESCR	256
+#define UMAL_MAX_RXDESCR	256
+
+#define ENET_PACKET_SIZE	1518
+
+/* Time in jiffies before concluding the transmitter is hung. */
+#define TX_TIMEOUT		(2*HZ)
+
+/*
+ * struct umaldma_desc - DMA Descriptor structure
+ */
+struct umaldma_desc {
+	dma_addr_t   packet_start_addr;
+	int          packet_size;
+	dma_addr_t   next_descriptor;
+	struct umaldma_desc *next_desc_virt;
+};
+
+/**
+ * struct umadlma - DMA Controller structure
+ * @umaldma_eth: back pointer to associated MAC
+ * @umaldma_txdir: direction(1 = transmit)
+ * @umaldma_maxdescr: total number of descriptors in ring
+ * @umaldma_desc_table: base of the descriptor table
+ * @umaldma_desc_table_unaligned: base of the descriptor table unaligned
+ * @umaldma_desc_table_phys: phys addr
+ * @umaldma_desc_table_phys_unaligned: another phys addr
+ * @umaldma_desc_table_end: the end of the descriptor table
+ * @umaldma_ctxtable: context table, one per descr
+ * @umaldma_addptr: next dscr for sw to add
+ * @umaldma_remptr: next dscr for sw to remove
+ *
+ * DMA Controller.
+ * umaldma_eth, umaldma_txdir, umaldma_maxdescr is used to identify
+ * the channel and the registers associated with it.
+ * And the following other members is used for maintenance of the ring.
+ */
+struct umaldma {
+	/*
+	 * This stuff is used to identify the channel and the registers
+	 * associated with it.
+	 */
+	/* back pointer to associated MAC */
+	struct netdev_puv3_softc	*umaldma_eth;
+	/* direction (1=transmit) */
+	int			umaldma_txdir;
+	/* total # of descriptors in ring */
+	int			umaldma_maxdescr;
+	/*
+	 * This stuff is for maintenance of the ring
+	 */
+	/* base of descriptor table */
+	struct umaldma_desc	*umaldma_desc_table;
+	void			*umaldma_desc_table_unaligned;
+	dma_addr_t		umaldma_desc_table_phys;
+	dma_addr_t		umaldma_desc_table_phys_unaligned;
+	struct umaldma_desc	*umaldma_desc_table_end;
+	/* context table, one per descr */
+	struct sk_buff		**umaldma_ctxtable;
+	/* next dscr for sw to add */
+	struct umaldma_desc	*umaldma_addptr;
+	/* next dscr for sw to remove */
+	struct umaldma_desc	*umaldma_remptr;
+};
+
+/*
+ * struct my_struct -  Ethernet softc structure
+ */
+struct netdev_puv3_softc {
+	struct net_device	*netdev_puv3_dev;
+	int			netdev_puv3_idx;
+	struct phy_device	*phy_dev;
+	struct mii_bus		*mii_bus;
+	int			phy_irq[PHY_MAX_ADDR];
+	spinlock_t		netdev_puv3_lock;
+	int			netdev_puv3_devflags;
+
+	enum netdev_puv3_state	netdev_puv3_state;
+	unsigned char		netdev_puv3_hwaddr[ETH_ALEN];
+
+	int			netdev_puv3_speed;
+	int			netdev_puv3_duplex;
+	enum netdev_puv3_flowc	netdev_puv3_flowc;
+	int			netdev_puv3_pause;
+	int			netdev_puv3_link;
+
+	struct umaldma		netdev_puv3_rxdma;
+	struct umaldma		netdev_puv3_txdma;
+};
+
+/*
+ * MII Bus functions  - for PAL (phy abstraction layer)
+ */
+
+/**
+ * netdev_puv3_mii_reset() - Reset MII bus.
+ * @bus: MDIO bus handle.
+ *
+ * MII Bus functions for PAL (phy abstraction layer)
+ * Reset MII bus.
+ * Return value, 0 if ok.
+ */
+static int netdev_puv3_mii_reset(struct mii_bus *bus)
+{
+	/* reset the MII management */
+	writel(UMAL_MIICFG_RESET, UMAL_MIICFG);
+	/* enable the MII management */
+	writel(0, UMAL_MIICFG);
+	/* source clock division = 28 */
+	writel(readl(UMAL_MIICFG) | 0x7, UMAL_MIICFG);
+
+	return 0;
+}
+
+/**
+ * netdev_puv3_mii_read() - Read a PHY register.
+ * @bus: MDIO bus handle
+ * @phyaddr: PHY's address
+ * @regidx: index of register to read
+ *
+ * MII Bus functions for PAL (phy abstraction layer)
+ * Read a PHY register.
+ * Return valume, value read, or 0xffff if an error occurred.
+ */
+static int netdev_puv3_mii_read(struct mii_bus *bus, int phyaddr, int regidx)
+{
+	int tmp = 0;
+
+	writel((phyaddr<<8) | regidx, UMAL_MIIADDR);
+	writel(UMAL_MIICMD_READ, UMAL_MIICMD);
+
+	tmp = readl(UMAL_MIIIDCT);
+	while (tmp & UMAL_MIIIDCT_BUSY)
+		tmp = readl(UMAL_MIIIDCT);
+
+	if (tmp & UMAL_MIIIDCT_NOTVALID)
+		return 0xffff;
+
+	writel(0, UMAL_MIICMD);
+
+	tmp = readl(UMAL_MIISTATUS);
+	return tmp;
+}
+
+/**
+ * netdev_puv3_mii_write() - Write a value to a PHY register.
+ * @bus: MDIO bus handle
+ * @phyaddr: PHY to use
+ * @regidx: register within the PHY
+ * @val: data to write to register
+ *
+ * MII Bus functions for PAL (phy abstraction layer)
+ * Write a value to a PHY register
+ * Return value, 0 if ok
+ */
+static int netdev_puv3_mii_write(struct mii_bus *bus, int phyaddr, int regidx,
+		u16 val)
+{
+	int tmp = 0;
+
+	writel((phyaddr<<8) | regidx, UMAL_MIIADDR);
+	writel(val, UMAL_MIICTRL);
+
+	tmp = readl(UMAL_MIIIDCT);
+	while (tmp & UMAL_MIIIDCT_BUSY)
+		tmp = readl(UMAL_MIIIDCT);
+
+	return 0;
+}
+
+/**
+ * netdev_puv3_clr_intr() - Clear all interrupt of umal
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Clear all interrupt of umal
+ * Return value, nothing
+ */
+static void netdev_puv3_clr_intr(struct net_device *dev)
+{
+	unsigned int int_status;
+
+	if (!netif_device_present(dev))
+		return;
+
+	int_status = readl(UMAL_DMAInterrupt);
+	if (int_status & INT_RX_PKT)
+		writel(CLR_RX_PKT, UMAL_DMARxStatus);
+
+	if (int_status & INT_RX_BUS_ERR)
+		writel(CLR_RX_BUS_ERR, UMAL_DMARxStatus);
+
+	if (int_status & INT_RX_OVERFLOW)
+		writel(CLR_RX_OVERFLOW, UMAL_DMARxStatus);
+
+	if (int_status & INT_TX_PKT)
+		writel(CLR_TX_PKT, UMAL_DMATxStatus);
+
+	if (int_status & INT_TX_BUS_ERR)
+		writel(CLR_TX_BUS_ERR, UMAL_DMATxStatus);
+
+	if (int_status & INT_TX_UNDERRUN)
+		writel(CLR_TX_UNDERRUN, UMAL_DMATxStatus);
+}
+
+/**
+ * netdev_puv3_promiscuous_mode() - Turn on or off promiscuous mode
+ * @sc: softc
+ * @onoff: 1 to turn on, 0 to turn off
+ *
+ * UMAL functions
+ * Turn on or off promiscuous mode
+ * Return value, nothing
+ */
+static void netdev_puv3_promiscuous_mode(struct netdev_puv3_softc *sc,
+		int onoff)
+{
+	if (onoff) {
+		writel(readl(UMAL_FIFOCFG4) & ~0x40000, UMAL_FIFOCFG4);
+		writel(readl(UMAL_FIFOCFG5) | 0x40000, UMAL_FIFOCFG5);
+	} else {
+		writel(readl(UMAL_FIFOCFG4) | 0x40000, UMAL_FIFOCFG4);
+		writel(readl(UMAL_FIFOCFG5) & ~0x40000, UMAL_FIFOCFG5);
+	}
+}
+
+/**
+ * netdev_puv3_set_speed() - Configure LAN speed for the specified MAC.
+ * @s: sbmac structure
+ * @speed: speed to set MAC to (see enum sbmac_speed)
+ *
+ * UMAL functions
+ * Configure LAN speed for the specified MAC.
+ * Warning: must be called when MAC is off!
+ * Return value,
+ *	1 if successful
+ *	0 indicates invalid parameters
+ */
+static int netdev_puv3_set_speed(struct netdev_puv3_softc *s, int speed)
+{
+	unsigned int cfg;
+
+	/* Save new current values */
+	s->netdev_puv3_speed = speed;
+
+	if (s->netdev_puv3_state == netdev_puv3_state_on)
+		return 0;	/* save for next restart */
+
+	/* Read current register values */
+	cfg = readl(UMAL_CFG2);
+
+	/* Mask out the stuff we want to change */
+	cfg &= ~(UMAL_CFG2_MODEMASK);
+
+	/* Now add in the new bits */
+	switch (speed) {
+	case SPEED_10:
+	case SPEED_100:
+		cfg |= UMAL_CFG2_NIBBLEMODE;
+		break;
+
+	default:
+		return 0;
+	}
+
+	/* Send the bits back to the hardware */
+	writel(cfg, UMAL_CFG2);
+
+	return 1;
+}
+
+/**
+ * netdev_puv3_set_duplex() - Set Ethernet duplex and flow control options for this MAC
+ * @s: umal structure
+ * @duplex: duplex setting (see enum sbmac_duplex)
+ * @flowc: flow control setting (see enum sbmac_flowc)
+ *
+ * UMAL functions
+ * Set Ethernet duplex and flow control options for this MAC
+ * Warning: must be called when MAC is off!
+ * Return value,
+ *	 1 if ok
+ *	 0 if an invalid parameter combination was specified
+ */
+static int netdev_puv3_set_duplex(struct netdev_puv3_softc *s, int duplex,
+		enum netdev_puv3_flowc flowc)
+{
+	unsigned int cfg1, cfg2;
+	int err = 0;
+
+	/* Save new current values */
+	s->netdev_puv3_duplex = duplex;
+	s->netdev_puv3_flowc = flowc;
+
+	if (s->netdev_puv3_state == netdev_puv3_state_on)
+		return 0;	/* save for next restart */
+
+	/* Read current register values */
+	cfg1 = readl(UMAL_CFG1);
+	cfg2 = readl(UMAL_CFG2);
+
+	/* Mask off the stuff we're about to change */
+	cfg1 &= ~(UMAL_CFG1_TXFLOWCTL | UMAL_CFG1_RXFLOWCTL);
+	cfg2 &= ~(UMAL_CFG2_FULLDUPLEX);
+
+	err = 0;
+	switch (duplex) {
+	case DUPLEX_HALF:
+		break;
+
+	case DUPLEX_FULL:
+		cfg2 |= UMAL_CFG2_FULLDUPLEX;
+		break;
+
+	default:
+		err = 1;
+	}
+	if (!err)
+		writel(cfg2, UMAL_CFG2);
+
+	err = 0;
+	switch (flowc) {
+	case netdev_puv3_flowc_disabled:
+		break;
+
+	case netdev_puv3_flowc_collision:
+		break;
+
+	case netdev_puv3_flowc_carrier:
+		break;
+
+	case netdev_puv3_flowc_frame:
+		cfg1 |= UMAL_CFG1_TXFLOWCTL | UMAL_CFG1_RXFLOWCTL;
+		break;
+
+	default:
+		err = 1;
+	}
+
+	if (!err)
+		writel(cfg1, UMAL_CFG1);
+
+	/* Send the bits back to the hardware */
+	return 1;
+}
+
+/**
+ * umaldma_channel_start() - Open a DMA channel.
+ * @d: DMA channel to init (context must be previously init'd)
+ * @rxtx: UMALDMA_RX or UMALDMA_TX depending on what type of channel
+ *
+ * UMAL DMA functions
+ * Open a DMA channel
+ * Return value, nothing
+ */
+static void umaldma_channel_start(struct umaldma *d, int rxtx)
+{
+	/*
+	 * Turn on the DMA channel
+	 */
+	if (rxtx == UMALDMA_TX) {
+		writel(d->umaldma_desc_table_phys, UMAL_DMATxDescriptor);
+		writel(UMAL_DMA_Enable, UMAL_DMATxCtrl);
+	} else {
+		writel(d->umaldma_desc_table_phys, UMAL_DMARxDescriptor);
+		writel(UMAL_DMA_Enable, UMAL_DMARxCtrl);
+	}
+}
+
+/**
+ * umaldma_channel_stop() - Close DMA channel.
+ * @d: DMA channel to init (context must be previously init'd
+ *
+ * UMAL DMA functions
+ * Close DMA channel.
+ * Return value, nothing
+ */
+static void umaldma_channel_stop(struct umaldma *d)
+{
+	/*
+	 * Turn off the DMA channel
+	 */
+	if (d->umaldma_txdir == UMALDMA_TX) {
+		writel(0, UMAL_DMATxCtrl);
+		writel(0, UMAL_DMATxDescriptor);
+	} else {
+		writel(0, UMAL_DMARxCtrl);
+		writel(0, UMAL_DMARxDescriptor);
+	}
+
+	/*
+	 * Zero ring pointers
+	 */
+	d->umaldma_addptr = d->umaldma_desc_table;
+	d->umaldma_remptr = d->umaldma_desc_table;
+}
+
+/**
+ * umaldma_add_rcvbuffer() - Add a buffer to the specified DMA channel.
+ * @sc: softc structure
+ * @d: DMA channel descriptor
+ * @sb: sk_buff to add, or NULL if we shoule allocate one
+ *
+ * UMAL DMA functions
+ * Add a buffer to the specified DMA channel.
+ * For receive channels, this queues a buffer for inbound packets.
+ * Return calue,
+ *	0 if buffer coule could not be added(ring is full)
+ *	1 if buffer added successfully
+ */
+static int umaldma_add_rcvbuffer(struct netdev_puv3_softc *sc,
+		struct umaldma *d, struct sk_buff *sb)
+{
+	struct net_device *dev = sc->netdev_puv3_dev;
+	struct umaldma_desc *dsc;
+	struct umaldma_desc *nextdsc;
+	struct sk_buff *sb_new = NULL;
+
+	/* get pointer to our current place in the ring */
+	dsc = d->umaldma_addptr;
+	nextdsc = UMALDMA_NEXTBUF(d, umaldma_addptr);
+
+	/*
+	 * figure out if the ring is full - if the next descriptor
+	 * is the same as the one that we're going to remove from
+	 * the ring, the ring is full
+	 */
+	if (nextdsc == d->umaldma_remptr)
+		return -ENOSPC;
+
+	/*
+	 * Allocate a sk_buff if we don't already have one.
+	 * If we do have an sk_buff, reset it so that it's empty.
+	 *
+	 * Note: sk_buffs don't seem to be guaranteed to have any sort
+	 * of alignment when they are allocated.  Therefore, allocate enough
+	 * extra space to make sure that:
+	 *
+	 *    1. the data does not start in the middle of a cache line.
+	 *    2. The data does not end in the middle of a cache line
+	 *    3. The buffer can be aligned such that the IP addresses are
+	 *       naturally aligned.
+	 *
+	 *  Remember, the SOCs MAC writes whole cache lines at a time,
+	 *  without reading the old contents first.  So, if the sk_buff's
+	 *  data portion starts in the middle of a cache line, the SOC
+	 *  DMA will trash the beginning (and ending) portions.
+	 */
+	if (sb == NULL) {
+		sb_new = netdev_alloc_skb(dev, ENET_PACKET_SIZE +
+			SMP_CACHE_BYTES * 2 + NET_IP_ALIGN);
+		if (sb_new == NULL) {
+			pr_info("%s: sk_buff allocation failed\n",
+				d->umaldma_eth->netdev_puv3_dev->name);
+			return -ENOMEM;
+		}
+		skb_reserve(sb_new, SMP_CACHE_BYTES + NET_IP_ALIGN);
+	} else {
+		sb_new = sb;
+		/*
+		 * nothing special to reinit buffer, it's already aligned
+		 * and sb->data already points to a good place.
+		 */
+	}
+
+	/* fill in the descriptor */
+	dsc->packet_start_addr = virt_to_phys(sb_new->data);
+	dsc->packet_size      = UMAL_DESC_PACKETSIZE_EMPTY;
+
+	/* fill in the context */
+	d->umaldma_ctxtable[dsc-d->umaldma_desc_table] = sb_new;
+
+	/* point at next packet */
+	d->umaldma_addptr = nextdsc;
+
+	return 0;
+}
+
+/**
+ * umaldma_fillring() - Fill the specified DMA channel with sk_buffs
+ * @sc: softc structure
+ * @d: DMA channel
+ *
+ * UMAL DMA functions
+ * Fill the specified DMA channel (must be receive channel) with sk_buffs
+ * Return value, nothing
+ */
+static void umaldma_fillring(struct netdev_puv3_softc *sc, struct umaldma *d)
+{
+	int idx;
+	for (idx = 0; idx < UMAL_MAX_RXDESCR - 1; idx++) {
+		if (umaldma_add_rcvbuffer(sc, d, NULL) != 0)
+			break;
+	}
+}
+
+/**
+ * netdev_puv3_channel_start() - Start packet processing on this MAC.
+ * @s: umal context structure
+ *
+ * UMAL Channel functions
+ * Start packet processing on this MAC.
+ * Return value, nothing
+ */
+static void netdev_puv3_channel_start(struct netdev_puv3_softc *s)
+{
+	/*
+	 * Don't do this if running
+	 */
+	if (s->netdev_puv3_state == netdev_puv3_state_on)
+		return;
+
+	/* don't accept any packets, disable all interrupts */
+	umaldma_channel_stop(&(s->netdev_puv3_rxdma));
+	umaldma_channel_stop(&(s->netdev_puv3_txdma));
+
+	writel(0, UMAL_DMAIntrMask);
+	netdev_puv3_clr_intr(s->netdev_puv3_dev);
+
+	/*
+	 * Program the hardware address.  It goes into the hardware-address
+	 * register as well as the first filter register.
+	 */
+	writel(s->netdev_puv3_hwaddr[0]<<24 | s->netdev_puv3_hwaddr[1]<<16 |
+		s->netdev_puv3_hwaddr[2]<<8 | s->netdev_puv3_hwaddr[3],
+		UMAL_STADDR1);
+	writel(s->netdev_puv3_hwaddr[4]<<24 |  s->netdev_puv3_hwaddr[5]<<16,
+		UMAL_STADDR2);
+
+	/* Configure the speed, duplex, and flow control */
+	netdev_puv3_set_speed(s, s->netdev_puv3_speed);
+	netdev_puv3_set_duplex(s, s->netdev_puv3_duplex, s->netdev_puv3_flowc);
+
+	/* If channel was in promiscuous mode before, turn that on */
+	if (s->netdev_puv3_devflags & IFF_PROMISC)
+		netdev_puv3_promiscuous_mode(s, 1);
+
+	/* Fill the receive ring */
+	umaldma_fillring(s, &(s->netdev_puv3_rxdma));
+
+	umaldma_channel_start(&(s->netdev_puv3_rxdma), UMALDMA_RX);
+	umaldma_channel_start(&(s->netdev_puv3_txdma), UMALDMA_TX);
+
+	s->netdev_puv3_state = netdev_puv3_state_on;
+
+	/* Initialize DMA channels (rings should be ok now) */
+	writel(INT_RX_BUS_ERR | INT_RX_OVERFLOW |
+			INT_RX_PKT        | INT_TX_BUS_ERR |
+			INT_TX_UNDERRUN   | INT_TX_PKT |
+			UMAL_DMAIntrMask_ENABLEHALFWORD, UMAL_DMAIntrMask);
+
+	/* we're running now.  */
+	writel(readl(UMAL_CFG1) | UMAL_CFG1_RXENABLE | UMAL_CFG1_TXENABLE,
+			UMAL_CFG1);
+}
+
+/**
+ * umaldma_emptyring() - Free all allocated sk_buffs on specified DMA channel.
+ * @d: DMA channel
+ *
+ * UMAL DMA functions
+ * Free all allocated sk_buffs on the specified DMA channel
+ * Return value, nothing
+ */
+static void umaldma_emptyring(struct umaldma *d)
+{
+	int idx;
+	struct sk_buff *sb;
+
+	for (idx = 0; idx < d->umaldma_maxdescr; idx++) {
+		sb = d->umaldma_ctxtable[idx];
+		if (sb) {
+			dev_kfree_skb(sb);
+			d->umaldma_ctxtable[idx] = NULL;
+		}
+	}
+}
+
+/**
+ * netdev_puv3_channel_stop() - Stop packet processing on this MAC.
+ * @s: umal context structure
+ *
+ * UMAL Channel functions
+ * Stop packet processing on this MAC.
+ * Return value, nothing
+ */
+static void netdev_puv3_channel_stop(struct netdev_puv3_softc *s)
+{
+	/* don't do this if already stopped */
+	if (s->netdev_puv3_state == netdev_puv3_state_off)
+		return;
+
+	/* don't accept any packets, disable all interrupts */
+	writel(0, UMAL_DMAIntrMask);
+	netdev_puv3_clr_intr(s->netdev_puv3_dev);
+
+	/* turn off receiver and transmitter */
+	writel(UMAL_CFG1_RESET, UMAL_CFG1);	/* reset MAC */
+	writel(0, UMAL_CFG1);
+
+	/* We're stopped now. */
+	s->netdev_puv3_state = netdev_puv3_state_off;
+
+	/* Stop DMA channels (rings should be ok now) */
+	umaldma_channel_stop(&(s->netdev_puv3_rxdma));
+	umaldma_channel_stop(&(s->netdev_puv3_txdma));
+
+	/* Empty the receive and transmit rings */
+	umaldma_emptyring(&(s->netdev_puv3_rxdma));
+	umaldma_emptyring(&(s->netdev_puv3_txdma));
+}
+
+/**
+ * netdev_puv3_miipoll() - Phy statemachine call back routine for link change
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Phy statemachine call back routine for link change
+ * Return value, nothing
+ */
+static void netdev_puv3_miipoll(struct net_device *dev)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	struct phy_device *phy_dev = sc->phy_dev;
+	unsigned long flags;
+	enum netdev_puv3_flowc flowc;
+	int link_chg, speed_chg, duplex_chg, pause_chg, flowc_chg;
+
+	link_chg = (sc->netdev_puv3_link != phy_dev->link);
+	speed_chg = (sc->netdev_puv3_speed != phy_dev->speed);
+	duplex_chg = (sc->netdev_puv3_duplex != phy_dev->duplex);
+	pause_chg = (sc->netdev_puv3_pause != phy_dev->pause);
+
+	if (!link_chg && !speed_chg && !duplex_chg && !pause_chg)
+		return;
+
+	if (!phy_dev->link) {
+		if (link_chg) {
+			sc->netdev_puv3_link = phy_dev->link;
+			sc->netdev_puv3_duplex = -1;
+			sc->netdev_puv3_flowc = netdev_puv3_flowc_disabled;
+			sc->netdev_puv3_pause = -1;
+			pr_info("%s: link unavailable\n", dev->name);
+		}
+		return;
+	}
+
+	if (phy_dev->duplex == DUPLEX_FULL) {
+		if (phy_dev->pause)
+			flowc = netdev_puv3_flowc_frame;
+		else
+			flowc = netdev_puv3_flowc_disabled;
+	} else
+		flowc = netdev_puv3_flowc_collision;
+	flowc_chg = (sc->netdev_puv3_flowc != flowc);
+
+	pr_info("%s: link available: %dbase-%cD\n", dev->name, phy_dev->speed,
+		phy_dev->duplex == DUPLEX_FULL ? 'F' : 'H');
+
+	spin_lock_irqsave(&sc->netdev_puv3_lock, flags);
+
+	sc->netdev_puv3_speed = phy_dev->speed;
+	sc->netdev_puv3_duplex = phy_dev->duplex;
+	sc->netdev_puv3_flowc = flowc;
+	sc->netdev_puv3_pause = phy_dev->pause;
+	sc->netdev_puv3_link = phy_dev->link;
+
+	if ((speed_chg || duplex_chg || flowc_chg) &&
+		sc->netdev_puv3_state != netdev_puv3_state_off) {
+		/* something changed, restart the channel */
+		netdev_puv3_channel_stop(sc);
+		netdev_puv3_channel_start(sc);
+	}
+
+	spin_unlock_irqrestore(&sc->netdev_puv3_lock, flags);
+}
+
+/**
+ * netdev_puv3_mii_probe() - Write a value to a PHY register.
+ * @dev: net_device structure
+ *
+ * MII Bus functions for PAL (phy abstraction layer)
+ * Write a value to a PHY register.
+ * Return value, 0 if ok.
+ */
+static int netdev_puv3_mii_probe(struct net_device *dev)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	struct phy_device *phy_dev;
+	int i;
+
+	for (i = 0; i < PHY_MAX_ADDR; i++) {
+		phy_dev = sc->mii_bus->phy_map[i];
+		if (phy_dev)
+			break;
+	}
+	if (!phy_dev) {
+		printk(KERN_ERR "%s: no PHY found\n", dev->name);
+		return -ENXIO;
+	}
+
+	phy_dev = phy_connect(dev, dev_name(&phy_dev->dev),
+			&netdev_puv3_miipoll, 0, PHY_INTERFACE_MODE_MII);
+	if (IS_ERR(phy_dev)) {
+		printk(KERN_ERR "%s: could not attach to PHY\n", dev->name);
+		return PTR_ERR(phy_dev);
+	}
+
+	/* Remove any features not supported by the controller */
+	phy_dev->supported &= SUPPORTED_10baseT_Half |
+			      SUPPORTED_10baseT_Full |
+			      SUPPORTED_100baseT_Half |
+			      SUPPORTED_100baseT_Full |
+			      SUPPORTED_Autoneg |
+			      SUPPORTED_MII;
+	phy_dev->advertising = phy_dev->supported;
+
+	pr_info("%s: attached PHY driver [%s] (mii_bus:phy_addr=%s, irq=%d)\n",
+		dev->name, phy_dev->drv->name,
+		dev_name(&phy_dev->dev), phy_dev->irq);
+
+	sc->phy_dev = phy_dev;
+
+	return 0;
+}
+
+/*
+ * UMAL DMA functions
+ */
+
+/**
+ * umaldma_initctx() - Initialize a DMA channel context.
+ * @d: struct umaldma (DMA channel context)
+ * @s: struct netdev_puv3_softc (pointer to a MAC)
+ * @rxtx: Identifies UMALDMA_TX or UMALDMA_RX for channel direction
+ * @maxdescr: number of descriptors
+ *
+ * UMAL DMA functions
+ * Initialize a DMA channel context.  Since there are potentially
+ * eight DMA channels per MAC, it's nice to do this in a standard
+ * way.
+ * Return value, nothing
+ */
+static void umaldma_initctx(struct umaldma *d, struct netdev_puv3_softc *s,
+		int rxtx, int maxdescr)
+{
+	struct umaldma_desc *dscr_item;
+	int idx;
+
+	/*
+	 * Save away interesting stuff in the structure
+	 */
+	d->umaldma_eth   = s;
+	d->umaldma_txdir = rxtx;
+	d->umaldma_maxdescr = maxdescr;
+
+	/*
+	 * Allocate memory for the ring
+	 */
+	d->umaldma_desc_table_unaligned = dma_alloc_coherent(NULL,
+					sizeof(*d->umaldma_desc_table),
+					&d->umaldma_desc_table_phys_unaligned,
+					GFP_KERNEL | GFP_DMA);
+	dma_cache_sync(NULL, d->umaldma_desc_table_unaligned,
+			sizeof(*d->umaldma_desc_table), DMA_BIDIRECTIONAL);
+
+	/*
+	 * The descriptor table must be aligned to at least 16 bytes or the
+	 * MAC will corrupt it.
+	 */
+	d->umaldma_desc_table = (struct umaldma_desc *)
+			ALIGN((unsigned long)d->umaldma_desc_table_unaligned,
+			sizeof(*d->umaldma_desc_table));
+	d->umaldma_desc_table_end = d->umaldma_desc_table + d->umaldma_maxdescr;
+	d->umaldma_desc_table_phys = ALIGN((unsigned long)
+				d->umaldma_desc_table_phys_unaligned,
+				sizeof(*d->umaldma_desc_table));
+
+	for (idx = 0; idx < d->umaldma_maxdescr; idx++) {
+		dscr_item = d->umaldma_desc_table + idx;
+		dscr_item->packet_start_addr = 0;
+		dscr_item->packet_size = UMAL_DESC_PACKETSIZE_EMPTY;
+		dscr_item->next_descriptor = (dma_addr_t)(
+			(struct umaldma_desc *)d->umaldma_desc_table_phys
+			+ (idx + 1));
+		dscr_item->next_desc_virt = d->umaldma_desc_table + (idx + 1);
+	}
+	dscr_item = d->umaldma_desc_table + (d->umaldma_maxdescr - 1);
+	dscr_item->next_descriptor = d->umaldma_desc_table_phys;
+	dscr_item->next_desc_virt = d->umaldma_desc_table;
+
+	d->umaldma_addptr = d->umaldma_desc_table;
+	d->umaldma_remptr = d->umaldma_desc_table;
+
+	d->umaldma_ctxtable = kcalloc(d->umaldma_maxdescr,
+				    sizeof(*d->umaldma_ctxtable), GFP_KERNEL);
+}
+
+/**
+ * umaldma_uninitctx() - Uninitialize a DMA channel context.
+ * @d: struct umaldma (DMA channel context)
+ *
+ * UMAL DMA functions
+ * Uninitialize a DMA channel context
+ * Return value, nothing
+ */
+static void umaldma_uninitctx(struct umaldma *d)
+{
+	if (d->umaldma_desc_table_unaligned) {
+		dma_free_coherent(NULL, sizeof(*d->umaldma_desc_table),
+				d->umaldma_desc_table_unaligned,
+				d->umaldma_desc_table_phys_unaligned);
+		d->umaldma_desc_table_unaligned = d->umaldma_desc_table = NULL;
+		d->umaldma_desc_table_phys_unaligned = 0;
+		d->umaldma_desc_table_phys = 0;
+	}
+
+	kfree(d->umaldma_ctxtable);
+	d->umaldma_ctxtable = NULL;
+}
+
+/**
+ * umaldma_add_txbuffer() - Add a transmit buffer to the specified DMA channel.
+ * @d: DMA channel descriptor
+ * @sb: sk_buff to add
+ *
+ * UMAL DMA functions
+ * Add a transmit buffer to the specified DMA channel, causing a
+ * transmit to start.
+ * Return value,
+ *	0 transmit queued successfully
+ *	otherwise error code
+ */
+static int umaldma_add_txbuffer(struct umaldma *d, struct sk_buff *sb)
+{
+	struct umaldma_desc *dsc;
+	struct umaldma_desc *nextdsc;
+
+	/* get pointer to our current place in the ring */
+	dsc = d->umaldma_addptr;
+	nextdsc = UMALDMA_NEXTBUF(d, umaldma_addptr);
+
+	/*
+	 * figure out if the ring is full - if the next descriptor
+	 * is the same as the one that we're going to remove from
+	 * the ring, the ring is full
+	 */
+	if (nextdsc == d->umaldma_remptr)
+		return -ENOSPC;
+
+	/*
+	 * fill in the descriptor.  Note that the number of cache
+	 * blocks in the descriptor is the number of blocks
+	 * *spanned*, so we need to add in the offset (if any)
+	 * while doing the calculation.
+	 */
+	dsc->packet_start_addr = virt_to_phys(sb->data);
+	dsc->packet_size      = sb->len | UMAL_DESC_PACKETSIZE_NONEMPTY;
+
+	dma_map_single(NULL, sb->data, sb->len, DMA_BIDIRECTIONAL);
+	dma_cache_sync(NULL, sb->data, sb->len, DMA_BIDIRECTIONAL);
+
+	/* fill in the context */
+	d->umaldma_ctxtable[dsc-d->umaldma_desc_table] = sb;
+
+	/* point at next packet */
+	d->umaldma_addptr = nextdsc;
+
+	return 0;
+}
+
+/**
+ * umaldma_rx_process() - Process "completed" receive buffers.
+ * @sc: softc structure
+ * @d: DMA channel context
+ * @work_to_do: no. of packets to process before enabling interrupt
+ *  again (for NAPI)
+ * @poll: 1. using polling (for NAPI)
+ *
+ * UMAL DMA functions
+ * Process "completed" receive buffers on the specified DMA channel.
+ * Return value, nothing
+ */
+static int umaldma_rx_process(struct netdev_puv3_softc *sc, struct umaldma *d,
+		int work_to_do, int poll)
+{
+	struct net_device *dev = sc->netdev_puv3_dev;
+	int curidx;
+	int hwidx;
+	struct umaldma_desc *dsc;
+	struct sk_buff *sb;
+	int len;
+	int work_done = 0;
+	int dropped = 0;
+	unsigned int int_status;
+
+	if (!netif_device_present(dev))
+		return 0;
+
+	int_status = readl(UMAL_DMAInterrupt);
+
+	if (int_status & INT_RX_BUS_ERR) {
+		writel(CLR_RX_BUS_ERR, UMAL_DMARxStatus);
+		writel(readl(UMAL_DMARxCtrl) | UMAL_DMA_Enable, UMAL_DMARxCtrl);
+	}
+
+	if (int_status & INT_RX_OVERFLOW) {
+		writel(CLR_RX_OVERFLOW, UMAL_DMARxStatus);
+		writel(readl(UMAL_DMARxCtrl) | UMAL_DMA_Enable, UMAL_DMARxCtrl);
+	}
+
+	if (!(int_status & INT_RX_PKT))
+		return 0;
+
+	while (work_to_do-- > 0) {
+		/*
+		 * figure out where we are (as an index) and where
+		 * the hardware is (also as an index)
+		 *
+		 * This could be done faster if (for example) the
+		 * descriptor table was page-aligned and contiguous in
+		 * both virtual and physical memory -- you could then
+		 * just compare the low-order bits of the virtual
+		 * address (sbdma_remptr) and the physical address
+		 * (sbdma_curdscr CSR)
+		 */
+		dsc = d->umaldma_remptr;
+		curidx = dsc - d->umaldma_desc_table;
+
+		hwidx = (struct umaldma_desc *) readl(UMAL_DMARxDescriptor) -
+			(struct umaldma_desc *)d->umaldma_desc_table_phys;
+
+		writel(CLR_RX_PKT, UMAL_DMARxStatus);
+
+		/*
+		 * If they're the same, that means we've processed all
+		 * of the descriptors up to (but not including) the one
+		 * that the hardware is working on right now.
+		 */
+		if (curidx == hwidx)
+			goto done;
+
+		/*
+		 * Otherwise, get the packet's sk_buff ptr back
+		 */
+		sb = d->umaldma_ctxtable[curidx];
+		len = dsc->packet_size & 0xfff;
+		d->umaldma_ctxtable[curidx] = NULL;
+
+		/* .. and advance to the next buffer.  */
+		d->umaldma_remptr = UMALDMA_NEXTBUF(d, umaldma_remptr);
+
+		/*
+		 * Check packet status.  If good, process it.
+		 * If not, silently drop it and put it back on the
+		 * receive ring.
+		 */
+		if (likely(!(dsc->packet_size & UMAL_DESC_PACKETSIZE_EMPTY))) {
+			/*
+			 * Add a new buffer to replace the old one.
+			 * If we fail to allocate a buffer, we're going
+			 * to drop this packet and put it right back on
+			 * the receive ring.
+			 */
+			if (unlikely(umaldma_add_rcvbuffer(sc, d, NULL)
+					== -ENOMEM)) {
+				dev->stats.rx_dropped++;
+				/* Re-add old buffer */
+				umaldma_add_rcvbuffer(sc, d, sb);
+				/* No point in continuing */
+				printk(KERN_ERR "dropped packet (1)\n");
+				d->umaldma_remptr = UMALDMA_NEXTBUF(d,
+						umaldma_remptr);
+				goto done;
+			} else {
+				/* Set length into the packet */
+				skb_put(sb, len + 4);
+
+				/*
+				 * Buffer has been replaced on the
+				 * receive ring.  Pass the buffer to
+				 * the kernel
+				 */
+				sb->protocol = eth_type_trans(sb,
+					d->umaldma_eth->netdev_puv3_dev);
+				/*
+				 * Check hw IPv4/TCP checksum
+				 * if supported
+				 */
+				skb_checksum_none_assert(sb);
+
+				if (poll)
+					dropped = netif_receive_skb(sb);
+				else
+					dropped = netif_rx(sb);
+
+				if (dropped == NET_RX_DROP) {
+					dev->stats.rx_dropped++;
+					d->umaldma_remptr = UMALDMA_NEXTBUF(d,
+							umaldma_remptr);
+					goto done;
+				} else {
+					dev->stats.rx_bytes += len;
+					dev->stats.rx_packets++;
+				}
+			}
+		} else {
+			/*
+			 * Packet was mangled somehow.  Just drop it and
+			 * put it back on the receive ring.
+			 */
+			dev->stats.rx_errors++;
+			umaldma_add_rcvbuffer(sc, d, sb);
+		}
+		work_done++;
+	}
+done:
+	return work_done;
+}
+
+/**
+ * umaldma_tx_process() - Process "completed" transmit buffers.
+ * @sc: softc structure
+ * @d: DMA channel context
+ * @poll: - 1, using polling (for NAPI)
+ *
+ * UMAL DMA functions
+ * Process "completed" transmit buffers on the specified DMA channel.
+ * This is normally called within the interrupt service routine.
+ * Note that this isn't really ideal for priority channels, since
+ * it processes all of the packets on a given channel before
+ * returning.
+ * Return value, nothing
+ */
+static void umaldma_tx_process(struct netdev_puv3_softc *sc, struct umaldma *d,
+		int poll)
+{
+	struct net_device *dev = sc->netdev_puv3_dev;
+	int curidx;
+	int hwidx;
+	struct umaldma_desc *dsc;
+	struct sk_buff *sb;
+	unsigned long flags;
+	int packets_handled = 0;
+	unsigned int int_status;
+
+	if (!netif_device_present(dev))
+		return;
+
+	spin_lock_irqsave(&(sc->netdev_puv3_lock), flags);
+
+	int_status = readl(UMAL_DMAInterrupt);
+
+	if (int_status & INT_TX_BUS_ERR)
+		writel(CLR_TX_BUS_ERR, UMAL_DMATxStatus);
+
+	if (int_status & INT_TX_UNDERRUN)
+		writel(CLR_TX_UNDERRUN, UMAL_DMATxStatus);
+
+	if (int_status & INT_TX_PKT) {
+		hwidx = (struct umaldma_desc *)readl(UMAL_DMATxDescriptor) -
+			(struct umaldma_desc *)d->umaldma_desc_table_phys;
+
+		if (d->umaldma_remptr == d->umaldma_addptr)
+			goto end_unlock;
+
+		for (;;) {
+			/*
+			 * figure out where we are (as an index) and where
+			 * the hardware is (also as an index)
+			 *
+			 * This could be done faster if (for example) the
+			 * descriptor table was page-aligned and contiguous in
+			 * both virtual and physical memory -- you could then
+			 * just compare the low-order bits of the virtual
+			 * address (sbdma_remptr) and the physical address
+			 * (sbdma_curdscr CSR)
+			 */
+			curidx = d->umaldma_remptr - d->umaldma_desc_table;
+
+			/*
+			 * If they're the same, that means we've processed all
+			 * of the descriptors up to (but not including) the one
+			 * that the hardware is working on right now.
+			 */
+			if (curidx == hwidx)
+				break;
+
+			/* Otherwise, get the packet's sk_buff ptr back */
+			dsc = &(d->umaldma_desc_table[curidx]);
+			sb = d->umaldma_ctxtable[curidx];
+
+			/* Stats */
+			dev->stats.tx_bytes += sb->len;
+			dev->stats.tx_packets++;
+
+			/* for transmits, we just free buffers.  */
+			dev_kfree_skb_irq(sb);
+			d->umaldma_ctxtable[curidx] = NULL;
+			writel(CLR_TX_PKT, UMAL_DMATxStatus);
+
+			/* .. and advance to the next buffer.  */
+			d->umaldma_remptr = UMALDMA_NEXTBUF(d, umaldma_remptr);
+			packets_handled++;
+		}
+
+		/*
+		 * Decide if we should wake up the protocol or not.
+		 * Other drivers seem to do this when we reach a low
+		 * watermark on the transmit queue.
+		 */
+		if (packets_handled)
+			netif_wake_queue(d->umaldma_eth->netdev_puv3_dev);
+	}
+
+end_unlock:
+	spin_unlock_irqrestore(&(sc->netdev_puv3_lock), flags);
+}
+
+/*
+ * UMAL Channel functions
+ */
+
+/**
+ * netdev_puv3_initctx() - Initialize an Ethernet context structure
+ * @s: umal context structure
+ *
+ * UMAL Channel functions
+ * Initialize an Ethernet context structure - this is called
+ * once per MAC. Memory is allocated here, so don't
+ * call it again from inside the ioctl routines that bring the
+ * interface up/down
+ * Return value, 0
+ */
+static int netdev_puv3_initctx(struct netdev_puv3_softc *s)
+{
+	/*
+	 * Initialize the DMA channels.
+	 * Note: Only do this _once_, as it allocates memory from the kernel!
+	 */
+	umaldma_initctx(&(s->netdev_puv3_txdma), s, UMALDMA_TX,
+			UMAL_MAX_TXDESCR);
+	umaldma_initctx(&(s->netdev_puv3_rxdma), s, UMALDMA_RX,
+			UMAL_MAX_RXDESCR);
+
+	/* initial state is OFF */
+	s->netdev_puv3_state = netdev_puv3_state_off;
+
+	return 0;
+}
+
+/**
+ * netdev_puv3_uninitctx() - Initialize an Ethernet context structure.
+ * @s: umal context structure
+ *
+ * UMAL Channel functions
+ * Initialize an Ethernet context structure.
+ * Memory is allocated here, so don't call it again from inside the
+ * ioctl routines that bring the interface up/down
+ * Return value, Nothing
+ */
+static void netdev_puv3_uninitctx(struct netdev_puv3_softc *s)
+{
+	umaldma_uninitctx(&(s->netdev_puv3_txdma));
+	umaldma_uninitctx(&(s->netdev_puv3_rxdma));
+}
+
+/**
+ * netdev_puv3_set_channel_state() - Set the channel's state ON or OFF
+ * @s: umal context structure
+ * @state: new state
+ *
+ * UMAL Channel functions
+ * Set the channel's state ON or OFF
+ * Return value, old state
+ */
+static enum netdev_puv3_state netdev_puv3_set_channel_state(
+		struct netdev_puv3_softc *s,
+		enum netdev_puv3_state state)
+{
+	enum netdev_puv3_state oldstate = s->netdev_puv3_state;
+
+	/* If same as previous state, return */
+	if (state == oldstate)
+		return oldstate;
+
+	/* If new state is ON, turn channel on */
+	if (state == netdev_puv3_state_on)
+		netdev_puv3_channel_start(s);
+	else
+		netdev_puv3_channel_stop(s);
+
+	/* Return previous state */
+	return oldstate;
+}
+
+/**
+ * netdev_puv3_set_rx_mode() - Set promiscuous mode and multicast list
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Set promiscuous mode and multicast list
+ * Return value, nothing
+ */
+static void netdev_puv3_set_rx_mode(struct net_device *dev)
+{
+	unsigned long flags;
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+
+	spin_lock_irqsave(&sc->netdev_puv3_lock, flags);
+	if ((dev->flags ^ sc->netdev_puv3_devflags) & IFF_PROMISC) {
+		/* Promiscuous changed.  */
+		if (dev->flags & IFF_PROMISC)
+			netdev_puv3_promiscuous_mode(sc, 1);
+		else
+			netdev_puv3_promiscuous_mode(sc, 0);
+	}
+	spin_unlock_irqrestore(&sc->netdev_puv3_lock, flags);
+}
+
+/**
+ * netdev_puv3_intr() - Interrupt handler for MAC interrupts
+ * @irq: irq number
+ * @dev_instance: net_device structure
+ *
+ * UMAL functions
+ * Interrupt handler for MAC interrupts
+ * Return value, irq handling result
+ */
+static irqreturn_t netdev_puv3_intr(int irq, void *dev_instance)
+{
+	struct net_device *dev = (struct net_device *) dev_instance;
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	uint64_t isr;
+	int handled = 0;
+
+	/*
+	 * Read the ISR (this clears the bits in the real
+	 * register, except for counter addr)
+	 */
+	isr = readl(UMAL_DMAInterrupt);
+	if (isr == 0)
+		return IRQ_RETVAL(0);
+
+	if (sc->netdev_puv3_state != netdev_puv3_state_on) {
+		netdev_puv3_clr_intr(dev);
+		return IRQ_RETVAL(0);
+	}
+	handled = 1;
+
+	/* Transmits on channel 0 */
+	if (isr & INT_TX_MASK)
+		umaldma_tx_process(sc, &(sc->netdev_puv3_txdma), 0);
+	if (isr & INT_RX_MASK)
+		umaldma_rx_process(sc, &(sc->netdev_puv3_rxdma),
+				 UMAL_MAX_RXDESCR * 2, 0);
+
+	return IRQ_RETVAL(handled);
+}
+
+/**
+ * netdev_puv3_open() - OPen umal device
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Open umal device
+ * Return value,
+ *	0 if ok
+ *	otherwise error
+ */
+static int netdev_puv3_open(struct net_device *dev)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	int err;
+
+	sc->netdev_puv3_speed = 0;
+	sc->netdev_puv3_duplex = -1;
+	sc->netdev_puv3_flowc = netdev_puv3_flowc_none;
+	sc->netdev_puv3_pause = -1;
+	sc->netdev_puv3_link = 0;
+
+	/* reset mac and interface */
+	writel(UMAL_CFG1_RESET, UMAL_CFG1);	/* reset MAC */
+	writel(0, UMAL_CFG1);			/* clear the reset bit of MAC */
+	writel(UMAL_IFCTRL_RESET, UMAL_IFCTRL);	/* reset the MAC Interface */
+	writel(0, UMAL_DMAIntrMask);
+
+	/* Attach to the PHY */
+	err = netdev_puv3_mii_probe(dev);
+	if (err)
+		goto out_unregister;
+
+	/* Turn on the channel */
+	phy_start(sc->phy_dev);
+
+	/* config fifo */
+	writel(0x000000ff, UMAL_FIFOCFG0);	/* reset FIFO */
+	writel(0x0fff0fff, UMAL_FIFOCFG1);
+	writel(0x0aaa0555, UMAL_FIFOCFG2);
+	writel(0x02800fff, UMAL_FIFOCFG3);
+	writel(0x00000070, UMAL_FIFOCFG4);
+	writel(0x0007ff8f, UMAL_FIFOCFG5);
+	writel(0x0000ff00, UMAL_FIFOCFG0);
+
+	writel(0x7016, UMAL_CFG2);
+
+	/*
+	 * map/route interrupt (clear status first, in case something
+	 * weird is pending; we haven't initialized the mac registers
+	 * yet)
+	 */
+	netdev_puv3_clr_intr(dev);
+
+	err = request_irq(dev->irq, netdev_puv3_intr, IRQF_SHARED, dev->name,
+			dev);
+	if (err) {
+		printk(KERN_ERR "%s: unable to get IRQ %d\n", dev->name,
+		       dev->irq);
+		goto out_err;
+	}
+
+	netdev_puv3_set_channel_state(sc, netdev_puv3_state_on);
+
+	netif_start_queue(dev);
+
+	netdev_puv3_set_rx_mode(dev);
+
+	return 0;
+
+out_unregister:
+	free_irq(dev->irq, dev);
+out_err:
+	return err;
+}
+
+/**
+ * netdev_puv3_close() - Close umal device
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Close umal device
+ * Return value, 0 if ok
+ */
+static int netdev_puv3_close(struct net_device *dev)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+
+	phy_stop(sc->phy_dev);
+
+	netdev_puv3_set_channel_state(sc, netdev_puv3_state_off);
+
+	netif_stop_queue(dev);
+
+	phy_disconnect(sc->phy_dev);
+	sc->phy_dev = NULL;
+
+	free_irq(dev->irq, dev);
+
+	umaldma_emptyring(&(sc->netdev_puv3_rxdma));
+	umaldma_emptyring(&(sc->netdev_puv3_txdma));
+
+	return 0;
+}
+
+/**
+ * netdev_puv3_mii_ioctl() - Umal device ioctrl routine
+ * @dev: net_device structure
+ * @rq: interface request structure
+ * @cmd: ioctrl command
+ *
+ * UMAL functions
+ * Umal device ioctrl routine
+ * Return value, ioctrl command result
+ */
+static int netdev_puv3_mii_ioctl(struct net_device *dev, struct ifreq *rq,
+		int cmd)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+
+	if (!netif_running(dev) || !sc->phy_dev)
+		return -EINVAL;
+
+	return phy_mii_ioctl(sc->phy_dev, rq, cmd);
+}
+
+/**
+ * netdev_puv3_start_tx() - Start output on the specified interface.
+ * @skb: sk_buff structure
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Start output on the specified interface.  Basically, we
+ * queue as many buffers as we can until the ring fills up, or
+ * we run off the end of the queue, whichever comes first.
+ * Return value,
+ *	0 if ok
+ *	otherwise error
+ */
+static int netdev_puv3_start_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	unsigned long flags;
+
+	/* lock eth irq */
+	spin_lock_irqsave(&sc->netdev_puv3_lock, flags);
+
+	/*
+	 * Put the buffer on the transmit ring.  If we
+	 * don't have room, stop the queue.
+	 */
+	if (umaldma_add_txbuffer(&(sc->netdev_puv3_txdma), skb)) {
+		/* XXX: save skb that we could not send */
+		netif_stop_queue(dev);
+		spin_unlock_irqrestore(&sc->netdev_puv3_lock, flags);
+
+		return NETDEV_TX_BUSY;
+	}
+
+	writel(readl(UMAL_CFG1) | UMAL_CFG1_TXENABLE, UMAL_CFG1);
+	writel(readl(UMAL_DMATxCtrl) | UMAL_DMA_Enable, UMAL_DMATxCtrl);
+
+	spin_unlock_irqrestore(&sc->netdev_puv3_lock, flags);
+
+	return 0;
+}
+
+/**
+ * netdev_puv3_tx_timeout() - Update statistic structure
+ * @dev: net_device structure
+ *
+ * UMAL functions
+ * Tx timeout, update statistic structure
+ * Return value, nothing
+ */
+static void netdev_puv3_tx_timeout(struct net_device *dev)
+{
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&sc->netdev_puv3_lock, flags);
+
+	dev->trans_start = jiffies; /* prevent tx timeout */
+	dev->stats.tx_errors++;
+
+	spin_unlock_irqrestore(&sc->netdev_puv3_lock, flags);
+
+	printk(KERN_WARNING "%s: Transmit timed out\n", dev->name);
+}
+
+/**
+ * netdev_puv3_change_mtu() - Change MTU value
+ * @dev: net_device structure
+ * @new_mtu: new mtu value
+ *
+ * UMAL functions
+ * Change MTU value
+ * Return value, 1 if ok
+ */
+static int netdev_puv3_change_mtu(struct net_device *dev, int new_mtu)
+{
+	if (new_mtu > ENET_PACKET_SIZE)
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+
+	pr_info("changing the mtu to %d\n", new_mtu);
+
+	return 0;
+}
+
+/*
+ * UMAL functions
+ */
+static const struct net_device_ops netdev_puv3_netdev_ops = {
+	.ndo_open		= netdev_puv3_open,
+	.ndo_stop		= netdev_puv3_close,
+	.ndo_start_xmit		= netdev_puv3_start_tx,
+	.ndo_set_rx_mode	= netdev_puv3_set_rx_mode,
+	.ndo_tx_timeout		= netdev_puv3_tx_timeout,
+	.ndo_do_ioctl		= netdev_puv3_mii_ioctl,
+	.ndo_change_mtu		= netdev_puv3_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address	= eth_mac_addr,
+};
+
+/**
+ * netdev_puv3_init() - init hardware and hook ourselves into linux.
+ * @pldev: net_device structure
+ * @base: unknown
+ *
+ * UMAL functions
+ * Attach routine - init hardware and hook ourselves into linux
+ * Return value, 0 if ok
+ */
+static int netdev_puv3_init(struct platform_device *pldev, long long base)
+{
+	struct net_device *dev = dev_get_drvdata(&pldev->dev);
+	int idx = pldev->id;
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+	unsigned char *eaddr;
+	int i;
+	int err;
+
+	sc->netdev_puv3_dev = dev;
+	sc->netdev_puv3_idx = idx;
+
+	eaddr = sc->netdev_puv3_hwaddr;
+
+#ifdef CONFIG_CMDLINE_FORCE
+	eaddr[0] = 0x00;
+	eaddr[1] = 0x25;
+	eaddr[2] = 0x9b;
+	eaddr[3] = 0xff;
+	eaddr[4] = 0x00;
+	eaddr[5] = 0x00;
+#endif
+
+	for (i = 0; i < 6; i++)
+		dev->dev_addr[i] = eaddr[i];
+
+	/* Set up Linux device callins */
+	spin_lock_init(&(sc->netdev_puv3_lock));
+
+	dev->netdev_ops = &netdev_puv3_netdev_ops;
+	dev->watchdog_timeo = TX_TIMEOUT;
+	dev->irq = IRQ_UMAL;
+
+	sc->mii_bus = mdiobus_alloc();
+	if (sc->mii_bus == NULL) {
+		err = -ENOMEM;
+		goto uninit_ctx;
+	}
+
+	sc->mii_bus->name = "umal-mdio";
+	snprintf(sc->mii_bus->id, MII_BUS_ID_SIZE, "%x", idx);
+	sc->mii_bus->priv = sc;
+	sc->mii_bus->read = netdev_puv3_mii_read;
+	sc->mii_bus->write = netdev_puv3_mii_write;
+	sc->mii_bus->reset = netdev_puv3_mii_reset;
+	sc->mii_bus->irq = sc->phy_irq;
+	for (i = 0; i < PHY_MAX_ADDR; ++i)
+		sc->mii_bus->irq[i] = PHY_POLL;
+
+	sc->mii_bus->parent = &pldev->dev;
+
+	/* Probe PHY address */
+	err = mdiobus_register(sc->mii_bus);
+	if (err) {
+		printk(KERN_ERR "%s: unable to register MDIO bus\n",
+		       dev->name);
+		goto free_mdio;
+	}
+	dev_set_drvdata(&pldev->dev, sc->mii_bus);
+
+	err = register_netdev(dev);
+	if (err) {
+		printk(KERN_ERR "%s.%d: unable to register netdev\n",
+		       UMAL_NAME, idx);
+		goto unreg_mdio;
+	}
+
+	pr_info("%s.%d: registered as %s\n", UMAL_NAME, idx, dev->name);
+
+	/*
+	 * Initialize context (get pointers to registers and stuff), then
+	 * allocate the memory for the descriptor tables.
+	 */
+	dev->dev.coherent_dma_mask = 0xFFFFFFFF;
+	netdev_puv3_initctx(sc);
+
+	/*
+	 * Display Ethernet address (this is called during the config
+	 * process so we need to finish off the config message that
+	 * was being displayed)
+	 */
+	pr_info("%s: UMAL Ethernet at 0x%08Lx, address: %pM\n",
+	       dev->name, base, eaddr);
+
+	return 0;
+unreg_mdio:
+	mdiobus_unregister(sc->mii_bus);
+	dev_set_drvdata(&pldev->dev, NULL);
+free_mdio:
+	mdiobus_free(sc->mii_bus);
+uninit_ctx:
+	netdev_puv3_uninitctx(sc);
+	return err;
+}
+
+static int __devinit netdev_puv3_probe(struct platform_device *pldev)
+{
+	struct net_device *dev;
+	struct netdev_puv3_softc *sc;
+	struct resource *res;
+	int err;
+
+	res = platform_get_resource(pldev, IORESOURCE_MEM, 0);
+	BUG_ON(!res);
+
+	/* Okay.  Initialize this MAC.  */
+	dev = alloc_etherdev(sizeof(struct netdev_puv3_softc));
+	if (!dev) {
+		printk(KERN_ERR "%s: unable to allocate etherdev\n",
+		       dev_name(&pldev->dev));
+		err = -ENOMEM;
+		goto out_out;
+	}
+
+	dev_set_drvdata(&pldev->dev, dev);
+	SET_NETDEV_DEV(dev, &pldev->dev);
+
+	sc = netdev_priv(dev);
+
+	err = netdev_puv3_init(pldev, res->start);
+	if (err)
+		goto out_kfree;
+
+	return 0;
+
+out_kfree:
+	free_netdev(dev);
+
+out_out:
+	return err;
+}
+
+static int __devexit netdev_puv3_remove(struct platform_device *pldev)
+{
+	struct net_device *dev = dev_get_drvdata(&pldev->dev);
+	struct netdev_puv3_softc *sc = netdev_priv(dev);
+
+	unregister_netdev(dev);
+	netdev_puv3_uninitctx(sc);
+	mdiobus_unregister(sc->mii_bus);
+	free_netdev(dev);
+
+	return 0;
+}
+
+#if CONFIG_PM
+static void netdev_puv3_reset(struct net_device *ndev)
+{
+	writel(UMAL_CFG1_RESET, UMAL_CFG1);	/* reset MAC */
+	writel(0, UMAL_CFG1);			/* clear the reset bit of MAC */
+	writel(UMAL_IFCTRL_RESET, UMAL_IFCTRL); /* reset the MAC Interface */
+	writel(1, UMAL_DMAIntrMask);
+
+	writel(0x000000ff, UMAL_FIFOCFG0);	/* reset FIFO */
+	writel(0x0fff0fff, UMAL_FIFOCFG1);
+	writel(0x0aaa0555, UMAL_FIFOCFG2);
+	writel(0x02800fff, UMAL_FIFOCFG3);
+	writel(0x00000070, UMAL_FIFOCFG4);
+	writel(0x0007ff8f, UMAL_FIFOCFG5);
+	writel(0x0000ff00, UMAL_FIFOCFG0);
+
+	writel(0x7016, UMAL_CFG2);
+}
+
+static void netdev_puv3_shutdown(struct net_device *ndev)
+{
+	/* XXX: something should be cleared */
+	return;
+}
+
+static int netdev_puv3_suspend(struct platform_device *pldev,
+		pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pldev);
+
+	if (netif_running(ndev)) {
+		netif_device_detach(ndev);
+		netdev_puv3_shutdown(ndev);
+	}
+	return 0;
+}
+
+static int netdev_puv3_resume(struct platform_device *pldev)
+{
+	struct net_device *dev = platform_get_drvdata(pldev);
+
+	if (netif_running(dev)) {
+		netdev_puv3_reset(dev);
+		netif_device_attach(dev);
+	}
+	return 0;
+}
+#else
+static int netdev_puv3_suspend(struct platform_device *pldev,
+		pm_message_t state) { }
+static int netdev_puv3_resume(struct platform_device *pldev) { }
+#endif
+
+static struct platform_driver netdev_puv3_driver = {
+	.probe = netdev_puv3_probe,
+	.remove = __devexit_p(netdev_puv3_remove),
+	.driver = {
+		.name = UMAL_NAME,
+		.owner  = THIS_MODULE,
+	},
+	.suspend = netdev_puv3_suspend,
+	.resume	 = netdev_puv3_resume,
+};
+
+module_platform_driver(netdev_puv3_driver);
+
+MODULE_DESCRIPTION("PKUNITY-3 SoC Ethernet driver");
+MODULE_LICENSE("GPL v2");
-- 
2.0.0.GIT

